{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fact sharing","text":"<p>A package for sharing the knowledge.</p> <p>This is a template for a python package following current (1-1-2024) best practices. This includes:</p> <ul> <li>Package structure</li> <li>Pyproject.toml as package description</li> <li>Linting/formatting with Ruff</li> <li>Precommit hook</li> <li>Tests with unittest</li> <li>GitLab build pipeline for linting, tests and building the package</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Use the package manager pip to install fact-sharing.</p> <pre><code>pip install fact-sharing\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Documentation is available here.</p> <pre><code>from fact_sharing import Person, find_common_knowledge\n\nhenkie = Person(\"henkie\", 23, {\"fact1\"})\nhenkie.forget_fact()\nprint(henkie.facts)  # {}\n\nhenkie.share_fact(\"fact2\")\nhenkie.share_fact(\"fact3\")\nprint(henkie.facts) # {\"fact2\", \"fact3\"}\n\nbetty = Person(\"betty\", 36, {\"fact2\", \"fact4\"})\nck = find_common_knowledge([henkie, betty])\nprint(ck)  # {\"fact2\"}\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.</p> <p>Please make sure to update tests as appropriate.</p>"},{"location":"#maintainer","title":"Maintainer","text":"<p>Jesse de Ruijter (jesse.de.ruijter@rivm.nl)</p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#fact_sharing","title":"<code>fact_sharing</code>","text":""},{"location":"reference/#fact_sharing.Person","title":"<code>Person</code>  <code>dataclass</code>","text":"<p>A person, a human being.</p> <p>Class for defining a person and all his knowledge.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>the name of the person.</p> <code>age</code> <code>int</code> <p>age of the person in years.</p> <code>facts</code> <code>set[str]</code> <p>a set of all the facts the person knows about.</p> Source code in <code>src/fact_sharing/objectmodels.py</code> <pre><code>@dataclass\nclass Person:\n    \"\"\"A person, a human being.\n\n    Class for defining a person and all his knowledge.\n\n    Attributes:\n        name (str): the name of the person.\n        age (int): age of the person in years.\n        facts (set[str]): a set of all the facts the person knows about.\n    \"\"\"\n\n    name: str\n    age: int\n    facts: set[str]\n\n    def forget_fact(self) -&gt; None:\n        \"\"\"Forget the a fact.\n\n        Examples:\n            &gt;&gt;&gt; p1 = Person(\"p1\", 15, {\"fact1\"})\n            &gt;&gt;&gt; p1.forget()\n            &gt;&gt;&gt; print(p1.facts)\n            {}\n        \"\"\"\n        if not self.facts:\n            return\n        self.facts.pop()\n\n    def share_fact(self, fact: str) -&gt; bool:\n        \"\"\"Share some knowledge.\n\n        Args:\n            fact (str): the fact to share.\n\n        Returns:\n            bool: if the fact was new knowledge to the person.\n\n        Examples:\n            &gt;&gt;&gt; person1 = Person(\"person1\", 15, {\"fact1\"})\n            &gt;&gt;&gt; fact2 = \"fact2\"\n            &gt;&gt;&gt; new_fact = person1.share_fact(fact2)\n            &gt;&gt;&gt; print(new_fact)\n            True\n\n            &gt;&gt;&gt; person1 = Person(\"person1\", 15, {\"fact1\"})\n            &gt;&gt;&gt; new_fact = person1.share_fact(\"fact1\")\n            &gt;&gt;&gt; print(new_fact)\n            False\n        \"\"\"\n        if fact in self.facts:\n            return False\n\n        self.facts.add(fact)\n        return True\n</code></pre>"},{"location":"reference/#fact_sharing.Person.forget_fact","title":"<code>forget_fact()</code>","text":"<p>Forget the a fact.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; p1 = Person(\"p1\", 15, {\"fact1\"})\n&gt;&gt;&gt; p1.forget()\n&gt;&gt;&gt; print(p1.facts)\n{}\n</code></pre> Source code in <code>src/fact_sharing/objectmodels.py</code> <pre><code>def forget_fact(self) -&gt; None:\n    \"\"\"Forget the a fact.\n\n    Examples:\n        &gt;&gt;&gt; p1 = Person(\"p1\", 15, {\"fact1\"})\n        &gt;&gt;&gt; p1.forget()\n        &gt;&gt;&gt; print(p1.facts)\n        {}\n    \"\"\"\n    if not self.facts:\n        return\n    self.facts.pop()\n</code></pre>"},{"location":"reference/#fact_sharing.Person.share_fact","title":"<code>share_fact(fact)</code>","text":"<p>Share some knowledge.</p> <p>Parameters:</p> Name Type Description Default <code>fact</code> <code>str</code> <p>the fact to share.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if the fact was new knowledge to the person.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; person1 = Person(\"person1\", 15, {\"fact1\"})\n&gt;&gt;&gt; fact2 = \"fact2\"\n&gt;&gt;&gt; new_fact = person1.share_fact(fact2)\n&gt;&gt;&gt; print(new_fact)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; person1 = Person(\"person1\", 15, {\"fact1\"})\n&gt;&gt;&gt; new_fact = person1.share_fact(\"fact1\")\n&gt;&gt;&gt; print(new_fact)\nFalse\n</code></pre> Source code in <code>src/fact_sharing/objectmodels.py</code> <pre><code>def share_fact(self, fact: str) -&gt; bool:\n    \"\"\"Share some knowledge.\n\n    Args:\n        fact (str): the fact to share.\n\n    Returns:\n        bool: if the fact was new knowledge to the person.\n\n    Examples:\n        &gt;&gt;&gt; person1 = Person(\"person1\", 15, {\"fact1\"})\n        &gt;&gt;&gt; fact2 = \"fact2\"\n        &gt;&gt;&gt; new_fact = person1.share_fact(fact2)\n        &gt;&gt;&gt; print(new_fact)\n        True\n\n        &gt;&gt;&gt; person1 = Person(\"person1\", 15, {\"fact1\"})\n        &gt;&gt;&gt; new_fact = person1.share_fact(\"fact1\")\n        &gt;&gt;&gt; print(new_fact)\n        False\n    \"\"\"\n    if fact in self.facts:\n        return False\n\n    self.facts.add(fact)\n    return True\n</code></pre>"},{"location":"reference/#fact_sharing.find_common_knowledge","title":"<code>find_common_knowledge(persons, minimum_persons=2)</code>","text":"<p>Determine the common knowledge of a list of people.</p> <p>Parameters:</p> Name Type Description Default <code>persons</code> <code>list[Person]</code> <p>the persons to retrieve the knowledge from.</p> required <code>minimum_persons</code> <code>int</code> <p>the minimum number of persons needed to calculate the common_knowledge. Defaults to 2.</p> <code>2</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>not enough persons passed to determine common knowledge.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: common knowledge.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; facts = [\"fact1\", \"fact2\"]\n&gt;&gt;&gt; persons = [\n&gt;&gt;&gt;     Person(\"p1\", 16, [\"fact1\", \"fact2\"]),\n&gt;&gt;&gt;     Person(\"p2\", 18, [\"fact2\", \"fact3\"]),\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; print(find_common_knowledge(persons))\nset(\"fact2\")\n</code></pre> Source code in <code>src/fact_sharing/utils.py</code> <pre><code>def find_common_knowledge(persons: list[Person], minimum_persons: int = 2) -&gt; set[str]:\n    \"\"\"Determine the common knowledge of a list of people.\n\n    Args:\n        persons (list[Person]): the persons to retrieve the knowledge from.\n        minimum_persons (int): the minimum number of persons needed to calculate the common_knowledge.\n            Defaults to 2.\n\n    Raises:\n        ValueError: not enough persons passed to determine common knowledge.\n\n    Returns:\n        set[str]: common knowledge.\n\n    Examples:\n        &gt;&gt;&gt; facts = [\"fact1\", \"fact2\"]\n        &gt;&gt;&gt; persons = [\n        &gt;&gt;&gt;     Person(\"p1\", 16, [\"fact1\", \"fact2\"]),\n        &gt;&gt;&gt;     Person(\"p2\", 18, [\"fact2\", \"fact3\"]),\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; print(find_common_knowledge(persons))\n        set(\"fact2\")\n    \"\"\"\n    if len(persons) &lt; minimum_persons:\n        msg = \"Not enough people to determine common knowledge.\"\n        raise ValueError(msg)\n\n    find_common_knowledge = persons[0].facts\n    for person in persons[1:]:\n        find_common_knowledge &amp;= person.facts\n    return find_common_knowledge\n</code></pre>"},{"location":"devops/checks/","title":"Code checks","text":"<p>It is important run certain checks, before committing new code and every time a merge/pull request is created.</p>"},{"location":"devops/checks/#checks-in-ide","title":"Checks in IDE","text":"<p>First you will have to do some checks in your IDE.</p>"},{"location":"devops/checks/#linting","title":"Linting","text":"<p>Install linter on pre-commit hook as described here.</p>"},{"location":"devops/checks/#commit-message-format","title":"Commit message format","text":"<p>Install a commit message checker on your pre-commit hook. For this project I used gitmoji to add emoji's to commits. By installing the VScode plugin or the CLI you can easily format you commit messages.</p>"},{"location":"devops/checks/#checks-in-merge-request","title":"Checks in Merge Request","text":"<p>When code is pushed to git or when a merge request is created, automated CI/CD pipelines will run more checks to determine if you are allowed to merge.</p>"},{"location":"devops/checks/#secret-scanning","title":"Secret scanning","text":"<p>Checks if there are secrets or connection strings leaked in your commit.</p> <pre><code># .gitlab-ci.yml\n\nstages:\n- test\n\ninclude:\n  - template: Jobs/Secret-Detection.gitlab-ci.yml\n</code></pre>"},{"location":"devops/checks/#dependency-scanning","title":"Dependency scanning","text":"<p>Checks in all versions of all your dependencies don't have vulnerabilties. There is a database with most packages and they track if there is any vulnerabilities for each version of these package.</p> <p>If your project depends on one of these versions this will warn you. Only available with GitLab Ultimate, but there are custom ways to implement this.</p> <pre><code># .gitlab-ci.yml\n\nstages:\n- test\n\ninclude:\n  - template: Security/Dependency-Scanning.gitlab-ci.yml\n</code></pre>"},{"location":"devops/checks/#linting_1","title":"Linting","text":"<p>Linting as described here</p>"},{"location":"devops/checks/#testing","title":"Testing","text":"<p>Testing as described here</p>"},{"location":"devops/checks/#release-tag","title":"Release tag","text":"<p>Check if the release tag is a correct semantic version. You can even check if only full versions are created on main.</p>"},{"location":"devops/checks/#changelog-version-inclusion","title":"Changelog version inclusion","text":"<p>A custom check that will look in the CHANGELOG.md file if it contains a change log for the current tagged version.</p>"},{"location":"devops/documentation/","title":"Documentation","text":""},{"location":"devops/documentation/#readmemd-and-changelogmd","title":"README.md and CHANGELOG.md","text":"<p>Two must-have files for each repository are <code>README.md</code> and <code>CHANGELOG.md</code>.</p>"},{"location":"devops/documentation/#readmemd","title":"README.md","text":"<p>This markdown file will be the starting point for every user that wants to use the package. It should at least have a package  description, describe a way to install the package, give some common examples of how to use it, tell you how to contribute to it or who maintains it.</p> <p>The readme is meant to be a one-pager or starting guide. It should not be used for documenting the whole project unless it is a very small package.</p> <p>You can use the following template:</p> <pre><code># Foobar\n\nFoobar is a Python library for dealing with word pluralization.\n\n## Installation\n\nUse the package manager [pip](https://pip.pypa.io/en/stable/) to install foobar.\n\n```bash\npip install foobar\n```\n\n## Usage\n\n```python\nimport foobar\n\n# returns 'words'\nfoobar.pluralize('word')\n```\n\n## Contributing\n\nPull requests are welcome. For major changes, please open an issue first\nto discuss what you would like to change.\n\nPlease make sure to update tests as appropriate.\n\n## License\n\n[MIT](https://choosealicense.com/licenses/mit/)\n</code></pre>"},{"location":"devops/documentation/#changelogmd","title":"CHANGELOG.md","text":"<p>It's a good practice to keep track of your changes per version. It is always possible to look up the all the changes per commit in git, but it is not easy to find in which tagged version you did a change.</p> <p>The <code>CHANGELOG.md</code> is a markdown file. Keep track of changes with the following keywords:</p> <ul> <li>Added for new features.</li> <li>Changed for changes in existing functionality.</li> <li>Deprecated for soon-to-be removed features.</li> <li>Removed for now removed features.</li> <li>Fixed for any bug fixes.</li> <li>Security in case of vulnerabilities.</li> </ul> <p>An example of a changelog file could be:</p> <pre><code>## [0.1.1] - 2024-03-20\n- **Added** a ```README.md```.\n\n## [0.1.0] - 2024-03-20\n- **Fixed** the ```find_common_knowledge``` less than 2 persons bug.\n- **Changed** the ```share_fact```-function to be part of ```Person```-class.\n\n## [0.0.1] - 2024-03-19\n- **Added** ```documentation``` about ```linting```.\n</code></pre>"},{"location":"devops/documentation/#wiki-documentation","title":"Wiki documentation","text":"<p>For larger projects it's a good idea to create a wiki (or wiki-like documentation). Most public packages have similar wiki's. These are static websites generated from markdown or rst files hosted on GitHub pages (or GitLab pages/Azure blob storage).</p>"},{"location":"devops/documentation/#documentation-with-mkdocs","title":"Documentation with mkdocs","text":"<p>A commonly used engine for creating these websites is Sphinx. This is a extensive library for creating documentation, but there are many simpler options.</p> <p>For this project I created this documentation using <code>mkdocs</code>. There is a docs-folder with all the markdown files. In a <code>mkdocs.yml</code> I configured the settings for generating the website.</p> <pre><code># mkdocs.yml\n\nsite_name: Fact Sharing\nsite_url: https://example.com/\nrepo_url: https://gitl01-int-p.rivm.nl/EPI/knowledgesharing/pythonpackage\n\nnav:\n  - Home: index.md\n  - DevOps:\n    - Linting: devops/linting.md\n    - Unit testing: devops/unit_testing.md\n    - Documentation: devops/documentation.md\n    - Packaging: devops/packaging.md\n  - Reference: reference.md\n</code></pre> <p>You can run <code>mkdocs serve</code> to serve the website on localhost, which you can view in the browser. This will automatically update to reflect the changes you make.</p> <p>When you want to build the website you can call <code>mkdocs build</code>, which will create a folder <code>site</code> containing the website.</p>"},{"location":"devops/documentation/#theming-mkdocs","title":"Theming mkdocs","text":"<p>You can customize the theme of the website. I used the material theme, which provides theming that follows the Google Material Design guidelines.</p> <pre><code># mkdocs.yml\n\ntheme:\n  name: material\n  favicon: assets/favicon.ico\n  logo: assets/logo.png\n  palette:\n    - media: \"(prefers-color-scheme: light)\"\n      scheme: default\n      primary: custom\n      accent: custom\n      toggle:\n        icon: material/weather-night\n        name: Switch to dark mode\n\n    - media: \"(prefers-color-scheme: dark)\"\n      scheme: slate\n      primary: custom\n      accent: custom\n      toggle:\n        icon: material/weather-sunny\n        name: Switch to light mode\n\nextra_css:\n  - stylesheets/extra.css\n</code></pre> <p>I set a custom favicon and logo, made a light/dark theme available with a custom color scheme (from RIVM).</p>"},{"location":"devops/documentation/#code-documentation-and-docstrings","title":"Code documentation and docstrings","text":"<p>Another important way of documentation is documenting the code itself.</p>"},{"location":"devops/documentation/#clean-code","title":"Clean code","text":"<p>The best way of documenting code is by writing clear code:</p> <ul> <li>Proper variable naming (follow the naming conventions of your language).<ul> <li>Make names descriptive: <code>facts</code>, not <code>f</code> or <code>x</code>.</li> <li>Don't include types: <code>persons</code>, not <code>person_list</code>.</li> <li>Use imperative statement for functions: <code>find_common_knowledge</code>, not <code>common_knowledge_from_people</code>.</li> </ul> </li> <li>Separate code in well-scoped functions/classes.</li> <li>Using design patterns to reduce coupling.</li> </ul>"},{"location":"devops/documentation/#comments","title":"Comments","text":"<p>Comments should be avoided, especially if the comment describes what the code does.</p> <pre><code># Get the common knowledge for 3 persons.\ncommon_knowledge = find_common_knowledge(persons, 3)\n</code></pre> <p>In this case the comment doesn't add any new information.</p> <pre><code># NOTE: the minimum_persons needs to be 3 in this specific case, because...\ncommon_knowledge = find_common_knowledge(persons, 3)\n</code></pre> <p>In this we explain why we need 3 people or more in this specific case instead of the usual 2. This is extra context we couldn't get from the code itself.</p> <p>In general only write commentst if they fall in one of the following categories:</p> <ul> <li>NOTE: Description of how the code works (when it isn't self evident).</li> <li>XXX: Warning about possible pitfalls.</li> <li>HACK: Not very well written or malformed code to circumvent a problem/bug.</li> <li>FIXME: This works, sort of, but it could be done better (usually code written in a hurry that needs rewriting).</li> <li>BUG: There is a problem here.</li> <li>TODO: No problem, but additional code needs to be written, usually when you are skipping something.</li> </ul>"},{"location":"devops/documentation/#docstrings","title":"Docstrings","text":"<p>A good place to describe what a function, class or module does, is in a docstring. There are different docstrings styles and linters. Your IDE will show the docstring when hovering over a function or writing it.</p> <p></p> <p>In this project I used google style:</p> <pre><code>def function_name(arg1: str, arg2: int = 2) -&gt; list[str]:\n    \"\"\"Short one-line description.\n\n    Optional multi-line description that goes into more details.\n\n    Args:\n        arg1 (str): description of arg1.\n        arg2 (int): description of arg2.\n            Defaults to 2.\n\n    Raises:\n        ValueError: an exception the function can raise.\n\n    Returns:\n        list[str]: description of result.\n\n    Examples:\n        &gt;&gt;&gt; # Example of how to use the function.\n        &gt;&gt;&gt; result = function_name(\"hi\")\n        &gt;&gt;&gt; print(result)\n        [\"hi\"]\n    \"\"\"\n    ...\n</code></pre> <p>It is important to not over-do it. Depending on who uses the function and how clear it is you can have a more limited version of the docstring.</p> <ul> <li>Always have a one-line description.</li> <li>Only use the long description if there is more to explain.</li> <li>Only use Args, Raises and Returns if it is not already clear from the function what it entails.</li> <li>Only provide Examples if it is a function that is used by for example external developers and mainly do this for you most important functions.</li> </ul> <p>So don't do this:</p> <pre><code>def multiple_by_2(x: float) -&gt; float:\n    \"\"\"Multiply a number by 2.\n\n    In this function a number is multiplied by 2.\n\n    Args:\n        x (float): the number to be multiplied by 2.\n\n    Returns:\n        float: the number multiplied by 2.\n\n    Examples:\n        &gt;&gt;&gt; print(multiply_by_2(3.0))\n        6.0\n    \"\"\"\n    return x * 2\n</code></pre> <p>Most IDEs have plugins to generate docstring templates. If you use co-pilot it can generate the whole docstring for you including contents.</p> <p>I used the <code>autoDocstring</code> extension in VScode to generate a docstring template after writing the function header.</p>"},{"location":"devops/documentation/#documentation-generation","title":"Documentation generation","text":"<p>Another advantage of using docstrings is you can use them to generate reference documentation.</p> <p>Mkdocs has a plugin called mkdocstrings. You can configure this plugin in the <code>mkdocs.yml</code>.</p> <pre><code>plugins:\n  - mkdocstrings:\n      handlers:\n        python:\n          paths: [src]\n          options:\n            show_root_heading: true\n            show_source: true\n</code></pre> <p>You can add the reference to a package, module, class or function in the markdown files.</p> <pre><code># mkdocs.yml\n::: fact_sharing\n\n::: fact_sharing.find_common_knowledge\n</code></pre> <p>This will generate reference documentation using the docstrings, like so.</p> <p>You can reference these objects in the rest of the website:</p> <pre><code>[][fact_sharing.find_common_knowledge]\n</code></pre> <p>Click on <code>reference</code>.</p>"},{"location":"devops/documentation/#automatic-publishing","title":"Automatic publishing","text":"<p>The last step is to host the documentation. Running <code>mkdocs build</code> creates a folder with a static website. This website can be hosted on:</p> <ul> <li>GitHub pages</li> <li>GitLab pages</li> <li>Azure blob storage</li> <li>AWS S3</li> <li>Any hosting platform</li> </ul> <p>We don't have GitLab pages available at RIVM, so I decided to publish it to a personal RIVM GitHub account, which is not ideal.</p> <pre><code>#.gitlab-ci.yml\nstages:\n- build\n- publish\n\nbuild_docs:\n  stage: build\n  script:\n    - pip install mkdocs mkdocs-material mkdocstrings[python]\n    - mkdocs build --site-dir public\n  artifacts:\n    paths:\n      - public\n  rules:\n    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'\n\nset_git:\n  stage: publish\n  script:\n    - cd public\n    - git config --global init.defaultBranch main\n    - git init\n    - git config user.name \"CI Pipeline\"\n    - git config user.email \"cipipeline@example.com\"\n    - git config remote.pages.url &gt;&amp;- || git remote add pages https://token:${GITHUB_PAT}@github.com/JessedeRuijterRIVM/ShareKnowledge.git/\n    - git fetch pages\n    - git add .\n    - git commit -m \"Update documentation [skip ci]\"\n    - git push -u pages HEAD:main --force\n  rules:\n    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'\n</code></pre> <p>In the documentation stage it will build the documentation and initialize a git-repo. In publish stage the code is force pushed to GitHub. These jobs only run on the default branch (main).</p>"},{"location":"devops/linting/","title":"Linting","text":"<p>An important tool for increasing code readability is using linters and formatters.</p>"},{"location":"devops/linting/#linters-formatters","title":"Linters &amp; formatters","text":"<p>A formatter can restructure your code without changing the behaviour of the code. Having a consistent formatting (like identation, brackets, spaces between operators) will make it easier to read and understand the code.</p> <p>A linter can check both stylistic and logical rules. It can suggest fixes for many issues like:</p> <ul> <li>Import sorting</li> <li>Unused variables and imports</li> <li>Code complexity</li> <li>Type checking</li> <li>Naming conventions</li> <li>And much more</li> </ul> <p>In this python project I use Ruff. This is a very fast rust-based linter is based on a collection of other linters/formatters, such as black, flake8, isort, pycodestyle and mccabe. All the rules of Ruff are documented here.</p> <p>Most linters are configurable and you can chose which rules to lint, what identation to use, which files to lint and much more. I used the following settings for this python project.</p> <pre><code>[tool.ruff]\nexclude = [\n    \".git\",\n    \".pytest_cache\",\n    \".ruff_cache\",\n    \".venv\",\n    \".vscode\",\n    \"venv\",\n    \"infra\",\n]\nline-length = 120\nindent-width = 4\n\n[tool.ruff.lint]\nselect = [\"ALL\"]\nignore = [\"ANN101\", \"D100\", \"D101\", \"D104\"]\nignore-init-module-imports = true\n\n[tool.ruff.lint.per-file-ignores]\n\"tests/*\" = [\"S101\"]\n\n[tool.ruff.lint.pydocstyle]\nconvention = \"google\"\n\n[tool.ruff.lint.mccabe]\nmax-complexity = 10\n</code></pre>"},{"location":"devops/linting/#pre-commit-hook","title":"Pre-commit hook","text":"<p>You can run your linter from console, for example for ruff you can run <code>ruff check . --fix</code>. In most IDE's it is possible to active format on save. This is not advised, because you will have to wait on the code being reformatted every time you save, and code jump to a different spot.</p> <p>The best way is linting just before committing to git. This can be automated by using the pre-commit hook. Git provides the following hooks:</p> <p></p> <p>It is possible to install scripts to these hooks, which will be executed when doing the corresponding action. The pre-commit hook, as the name suggests, will run before committing, which is a good moment to lint your code.</p> <p>In this python setup I installed <code>pip install pre-commit</code>. I created a <code>.pre-commit-config.yaml</code>, which contains 2 scripts:</p> <ul> <li>a script that executes Ruff.</li> <li>a script that lints the yaml files. You can easily use predefined script or write your own ones (documentation).</li> </ul> <p>This allows the user to run all the configured pre-commit steps by running the command <code>pre-commit run --all-files</code>.</p>"},{"location":"devops/linting/#linting-in-cicd","title":"Linting in CI/CD","text":"<p>Besides linting locally, it is also important to lint before completing Pull/Merge Requests. This can easily be done by adding a linting step in your CI/CD pipelines.</p> <p>For GitLab you can add the following to <code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n  - test\n\nlint_package:\n  stage: test\n  script:\n    - pip install --upgrade ruff\n    - python -m ruff check .\n</code></pre>"},{"location":"devops/packaging/","title":"Packaging","text":""},{"location":"devops/packaging/#folder-structure","title":"Folder structure","text":"<p>A good structure for python packages:</p> <pre><code>\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 assets\n\u2502   \u2502   \u2514\u2500\u2500 **/*.png\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u2514\u2500\u2500 reference.md\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 module1\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 *.py\n\u2502   \u2514\u2500\u2500 module2\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 *.py\n\u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_module1.py\n\u2502   \u2514\u2500\u2500 test_module2.py\n\u2502\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .gitlab-ci.yml\n\u251c\u2500\u2500 .pre-commit-config.yml\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 pyproject.tom;\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 setup.cfg\n</code></pre> <p>The pyproject.toml contains all the information about the project:</p> <ul> <li>build tools</li> <li>description</li> <li>dependencies</li> <li>optional dependencies</li> <li>linting options</li> </ul>"},{"location":"devops/packaging/#cookie-cutters","title":"Cookie cutters","text":"<p>A cookie cutter is a tool that can generate an empty project following a certain structure. By providing a cookie cutter with all the DevOps and CI/CD practices included, you take away all the setup work. I would suggest we create the following cookie cutter options:</p> <ul> <li>Python package</li> <li>Python API</li> <li>R package</li> <li>R shiny app</li> <li>SSIS package (if possible)</li> </ul>"},{"location":"devops/packaging/#package-deployment","title":"Package deployment","text":"<p>The last step is to build the python package to a .whl file and upload it to a package registry to make it available to other users.</p>"},{"location":"devops/packaging/#package-registry","title":"Package registry","text":"<p>We can either upload it to pypi, if it is public, or to a private package registry like in GitLab.</p> <p>Downloading from the public registry can be done by:</p> <pre><code>pip install package_name\n</code></pre> <p>or in a dependency file like pyproject.toml or requirements.txt.</p> <pre><code>package_name[pipeline] ~= 0.3.1\n</code></pre> <p>This would instaal the package dependencies and the optional dependencies of pipeline for the highest version that is compatible with 0.3.1.</p> <p>You can specify that you also allow dev-versions by doing:</p> <pre><code>package_name ~= 0.3.1.dev\n</code></pre> <p>This will take the highest version including dev versions.</p>"},{"location":"devops/packaging/#build-and-deploy","title":"Build and deploy","text":"<p>I added a job that builds the package if a new release tag is created. It will replace the version in the pyproject.toml with the version from the tag. Then it will build a .whl file and upload it to the GitLab package registry.</p> <pre><code># .gitlab-ci.yml\n\nstages:\n- build\n\nbuild_package:\n  stage: build\n  script:\n    - pip install --upgrade build\n    - sed -i -e \"s/0.0.0/$CI_COMMIT_TAG/\" pyproject.toml\n    - python -m build\n    - pip install --upgrade twine\n    - TWINE_PASSWORD=${CI_JOB_TOKEN} TWINE_USERNAME=gitlab-ci-token python -m twine upload --repository-url ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/pypi dist/*\n  only:\n    - tags\n</code></pre>"},{"location":"devops/unit_testing/","title":"Unit testing","text":"<p>There is multiple types of testing:</p> <ul> <li>Unit testing, does the function/class behave as expected.</li> <li>Integration testing, does the code behave as expected when integrated with other code/databases/API's.</li> <li>End-to-end testing, does the complete product behave as expected for the user.</li> </ul> <p>Especially unit tests are easy to implement in your work flow, as they are easy to write and run.</p>"},{"location":"devops/unit_testing/#writing-unit-tests","title":"Writing unit tests","text":""},{"location":"devops/unit_testing/#what-to-test","title":"What to test?","text":"<ul> <li>Success on likely case with parameters you expect.</li> <li>Success on case with empty lists and None (null) for each input.</li> <li>If the function can raise exceptions/errors, check if it does.</li> </ul> <p>For example:</p> <pre><code>class TestForgetFact(unittest.TestCase):\n    def test_forget_success(self) -&gt; None:\n        \"\"\"Test if it forgets a fact.\"\"\"\n        facts = {\n            \"The world's oldest cat lived to 38 years and three days old.\",\n            \"Giraffes are 30 times more likely to get hit by lightning than people.\",\n        }\n        person = Person(\"Ben\", 45, facts)\n        person.forget_fact()\n        assert len(person.facts) == 1\n\n    def test_no_fact(self) -&gt; None:\n        \"\"\"Test if it doesn't crash when there are no facts.\"\"\"\n        person = Person(\"Ben\", 45, [])\n        try:\n            person.forget_fact()\n        except TypeError as e:\n            msg = \"Forgetting empty facts crashed.\"\n            raise AssertionError(msg) from e\n</code></pre>"},{"location":"devops/unit_testing/#structure-code-for-unit-tests","title":"Structure code for unit tests","text":"<p>It is important that the code is structured in a way that makes it easier to test. This means functions should have a single responsibility, with well-defined in- and outputs and no side effects. Make sure interacting with services or databases is not mixed with business logic.</p>"},{"location":"devops/unit_testing/#single-responsibility","title":"Single responsibility","text":"<p>When a function does too much work, there is many different combinations to test. For example a function <code>def preprocess()</code> that does:</p> <ul> <li>Data cleaning</li> <li>Data imputation</li> <li>Feature engineering</li> <li>Logging</li> </ul> <p>You will have to test all the different combinations of inputs parameters for the different steps, blowing up the number of tests you will have to write. This is a integration test and unit test in one. The better approach would be making separate functions for each step and testing them separately. The whole process can be tested in an integration test.</p>"},{"location":"devops/unit_testing/#service-interactions-and-mocking","title":"Service interactions and mocking","text":"<p>Avoid mixing in interactions with external services in a function that also contains critical, functional logic. If there is a function <code>def get_data()</code> that both gets the data and does some transformation on it, then the transformation part is hard to unit test.</p> <p>You can still test a function with side effects by properly using dependency injection and mocking the connection.</p> <p>Don't do:</p> <pre><code>def get_data() -&gt; dict[str, int]:\n    connection = Connection()\n    api = API(connection)\n    data = api.retrieve_data()\n\n    processed_data = transform(data)\n    return processed_data\n\ndata = get_data()\n</code></pre> <p>Do:</p> <pre><code>def get_data(api: API) -&gt; dict[str, int]:\n    data = api.retrieve_data()\n\n    processed_data = transform(data)\n    return processed_data\n\n\nconnection = Connection()\napi = API(connection)\ndata = get_data(api)\n</code></pre> <p>and the test:</p> <pre><code>class MockAPI:\n    def __init__(self, data: dict[str, int]) -&gt; None:\n        self.data = data\n\n    def retrieve_data(self) -&gt; dict[str, int]:\n        return self.data\n\ndef test_get_data():\n    api = MockAPI({\"test\":1})\n    assert get_data(api)\n</code></pre>"},{"location":"devops/unit_testing/#running-the-tests","title":"Running the tests","text":"<p>You can always run unit tests from console. Most IDE's have plugins for running unit tests. In this project I used <code>unittest</code>-package to create the unit tests and the <code>pytest</code> package to view and run them in VScode.</p> <p></p> <p>It is a good practice to run your unit test before committing new code. It is not advised to add unit tests to the pre-commit hook as described in Linting. The reason is that running unit tests can take several minutes for a big project, which means you will have to wait before pushing.</p> <p>It is better to run them asynchronously in you CI/CD. The following GitLab snippet will run the tests for this project.</p> <pre><code># .gitlab-ci.yml\n\nstages:\n- test\n\ntest_package:\n  stage: test\n  script:\n  - pip install pytest pytest-cov\n  - pytest --cov --cov-report term --cov-report xml:coverage.xml\n  coverage: '/(?i)total.*? (100(?:\\.0+)?\\%|[1-9]?\\d(?:\\.\\d+)?\\%)$/'\n  artifacts:\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage.xml\n</code></pre> <p>The unit tests have to succeed before you can succesfully merge a Merge Request.</p>"},{"location":"devops/unit_testing/#code-coverage","title":"Code coverage","text":"<p>A metric that is handy to measure is the code coverage. This denotes the percentage of the codebase that is covered by unit tests. A team can make agreements about if this metric falls below a certain percentage, tasks regarding creating unit tests should be prioritized.</p> <p>Most unit testing packages have this included. For python I used <code>pytest-cov</code> and you can generate the report using:</p> <pre><code>pytest --cov --cov-report term --cov-report xml:coverage.xml\n</code></pre> <p>This generate a report which you can upload to GitLab as an artifact. GitLab will include this percentage with Merge Requests.</p> <p></p> <p>It also highlights uncovered code in the changes view:</p> <p></p> <p>At last there is also a view where you can see the code coverage over time per repo in Analyze/Repository analytics:</p> <p></p>"}]}